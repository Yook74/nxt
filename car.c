#pragma config(Sensor, S2,     Reciever,       sensorI2CCustom)
#pragma config(Sensor, S4,     Touch,          sensorTouch)
#pragma config(Motor,  motorA,          Steering,      tmotorNXT, PIDControl, encoder)
#pragma config(Motor,  motorB,          RightDrive,    tmotorNXT, openLoop)
#pragma config(Motor,  motorC,          LeftDrive,     tmotorNXT, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#include "drivers/hitechnic-irrecv.h"

#define CENTER_ENCODER -40
#define RIGHT_ENCODER -90
#define POWER_DELTA .1
#define POWER_WAIT_MS 200
#define TURN_POWER_CHANGE 0.7

sbyte lastError = 0;
sbyte errorChange = 0;
long totalError = 0;

void centerPid(sbyte steeringSpeed){
	sbyte error = CENTER_ENCODER - nMotorEncoder[Steering];
	totalError += error;

	float kPArr[5] = {0.7,  1,    1.5,  1.7,   2};
	float kDArr[5] = {2,    3,    4,    5.5,   7};
	float kIArr[5] = {0.02, 0.03, 0.05, 0.055, 0.06};

	motor[Steering] = error * kPArr[steeringSpeed] + errorChange * kDArr[steeringSpeed] + totalError * kIArr[steeringSpeed];

	if(time1[T4] >= 10){
		//writeDebugStreamLine("Error:%d P:%f  D:%f I:%f", error, error * KP, errorChange * KD, totalError * KI);
		errorChange = error - lastError;
		lastError = error;
		ClearTimer(T4);
	}
}

void resetEncoder(){
	motor[Steering] = 100;
	while (!SensorValue[Touch]){
		wait10Msec(1);
	}
	motor[Steering] = 0;
	nMotorEncoder[Steering] = 0;
}

task main()
{
	clearDebugStream(); // TODO

	sbyte turnSignal = 0;
	sbyte directionSignal = 0;
	sbyte drivePowerSignal = 0;
	sbyte steeringPowerSignal = 0;

	float leftTurnPowerLevel = 0;
	float rightTurnPowerLevel = 0;
	float overallDrivePower = .5;
	sbyte overallSteeringSpeed = 1;

	ClearTimer(T1);
	ClearTimer(T2);
	ClearTimer(T4);
	resetEncoder();
	while (true) {
		HTIRRreadChannel(Reciever, 4, directionSignal, turnSignal);
		HTIRRreadChannel(Reciever, 3, drivePowerSignal, steeringPowerSignal);

		if(drivePowerSignal != 0 && time1[T2] > POWER_WAIT_MS){
			ClearTimer(T2);

			if (drivePowerSignal < 0) overallDrivePower -= POWER_DELTA;
			if (drivePowerSignal > 0) overallDrivePower += POWER_DELTA;
			if (overallDrivePower < POWER_DELTA) overallDrivePower = POWER_DELTA;
			if (overallDrivePower > 1) overallDrivePower = 1;

			PlayImmediateTone(overallDrivePower * 1350, 100);
		}

		if(steeringPowerSignal != 0 && time1[T2] > POWER_WAIT_MS){
			ClearTimer(T2);

			if (steeringPowerSignal > 0) overallSteeringSpeed -= 1;
			if (steeringPowerSignal < 0) overallSteeringSpeed += 1;
			if (overallSteeringSpeed < 0) overallSteeringSpeed = 0;
			if (overallSteeringSpeed > 4) overallSteeringSpeed = 4;

			PlayImmediateTone(overallSteeringSpeed * 200 + 440, 100);
		}

		motor[LeftDrive] = directionSignal * leftTurnPowerLevel * overallDrivePower;
		motor[RightDrive] = directionSignal * rightTurnPowerLevel * overallDrivePower;

		if (turnSignal > 0){
			totalError = 0;
			leftTurnPowerLevel = 1 + TURN_POWER_CHANGE;
			rightTurnPowerLevel = 1 - TURN_POWER_CHANGE;
			if (SensorValue[Touch]){
      	nMotorEncoder[Steering] = 0;
      	motor[Steering] = 0;
		  } else {
			  motor[Steering] = 15 * overallSteeringSpeed + 25;
			}
		} else if (turnSignal < 0) {
			totalError = 0;
			leftTurnPowerLevel = 1 - TURN_POWER_CHANGE;
			rightTurnPowerLevel = 1 + TURN_POWER_CHANGE;
			if (nMotorEncoder[Steering] <= RIGHT_ENCODER)
				motor[Steering] = 0;
			else
				motor[Steering] = -15 * overallSteeringSpeed - 25;
		} else {
			leftTurnPowerLevel = 1;
			rightTurnPowerLevel = 1;
			centerPid(overallSteeringSpeed);
	  }
	}
}
